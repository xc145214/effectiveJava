# effective Java
****

## 1.创建和销毁对象

**01.考虑用静态工厂方法代替构造器**

静态工厂方法与构造器相比的优势：
+ 他们有名称
+ 不必每次调用的时候都创建一个新的对象
+ 可以返回原类型的任何子类型的对象
+ 在创建参数化类型实例的时候，代码更加简洁

静态工厂方法的缺点：
+ 类如果不含public或者protected 构造器，就不能被子类化
+ 与其它静态方法没有任何区别

**02.遇到多个构造参数的时候考虑使用构建器**

多个构造参数的类的选择
+ 重叠构造器模式：模式可行，但是遇到愈多参数的时候，代码难以编写，阅读
+ JavaBean模式：构造过程中可能处于不一致的状态，且阻止了将类做成不能变的可能。
+ Builder模式：最佳选择，弥补`Class.newInstance`破坏编译时检查异常的不足

**03.用私有构造器或者枚举强化Singleton属性**

实现Singleton的方法：
+ 公有静态成员是个 final 域
+ 公有成员是个静态工厂方法
+ 单元素的枚举类型：最佳方法，无偿提供序列化机制，绝对阻止多次实例化

**04.通过私有构造器强化不可实例化的能力**

+ 企图通过将类做成抽象类强制该类不可实例化，是行不通的
+ 添加显式的私有构造器

**05.避免创建不必要的对象**

+ 操作字符串，使用StringBuilder代替 +
+ 使用静态工厂方法
+ 静态的初始化器
+ 优先使用基本类型，当心无意识的自动装箱

**06.消除过期的对象引用**

+ 清空对象引用应该是一种例外而不是规范，最佳方式是让包含引用的变量结束其生命周期，即最紧凑作用域范围内定义每一个变量
+ 只要类是自己管理内存的，应当警惕内存泄漏问题，一旦元素被释放，则该元素中包含的任何对象应用都应该被清空

内存泄漏的常见来源：
+ 自己管理内存的类，比如栈
+ 缓存
+ 监听器和其他回调

**07.避免使用finalizer方法**
+ finalizer方法不可预测，危险，也是不必要的
+ finalizer方法有一个严重的性能损失
+ 使用显式的终止方法代替，通常与try-finally结构集合使用，确保及时终止

> 常见的InputStream,OutputStream,java.sql.Connection上的close方法，java.util.Timer的cancel方法

终结方法的优势：
+ 当对象的所有者调用显式的终止方法时，可以充当安全网

## 2.对于所有对象都通用的方法

**08.覆盖equals时请遵守通用约定**

应该覆盖equals方法的任一条件：
+ 类的每个实例的本质上都是唯一的
+ 不关心类是否提供了逻辑相等的测试功能
+ 超类已经覆盖了equals,从超类集成过来的行为对于子类也是合适的
+ 类是私有或者包级私有的，可以确定它的equals方法，
